{
  "version": 3,
  "sources": ["../_worker.js"],
  "sourceRoot": "minify",
  "sourcesContent": ["// <!--GAMFC-->version base on commit 43fad05dcdae3b723c53c226f8181fc5bd47223e, time is 2023-06-22 15:20:02 UTC<!--GAMFC-END-->.\n// @ts-ignore\nimport { connect } from 'cloudflare:sockets';\n// import { connectdb } from '@planetscale/database';\n\n// How to generate your own UUID:\n// [Windows] Press \"Win + R\", input cmd and run:  Powershell -NoExit -Command \"[guid]::NewGuid()\"\nlet userID = 'd342d11e-d424-4583-b36e-524ab1f0afa4';\n\nconst proxyIPs = ['cdn-all.xn--b6gac.eu.org', 'cdn.xn--b6gac.eu.org', 'cdn-b100.xn--b6gac.eu.org', 'edgetunnel.anycast.eu.org', 'cdn.anycast.eu.org'];\nlet proxyIP = proxyIPs[Math.floor(Math.random() * proxyIPs.length)];\n\nlet dohURL = 'https://sky.rethinkdns.com/1:-Pf_____9_8A_AMAIgE8kMABVDDmKOHTAKg='; // https://cloudflare-dns.com/dns-query or https://dns.google/dns-query\n\n// v2board api environment variables (optional)\n// now deprecated, please use planetscale.com instead\nlet nodeId = ''; // 1\n\nlet apiToken = ''; //abcdefghijklmnopqrstuvwxyz123456\n\nlet apiHost = ''; // api.v2board.com\n\nif (!isValidUUID(userID)) {\n\tthrow new Error('uuid is invalid');\n}\n\nexport default {\n\t/**\n\t * @param {import(\"@cloudflare/workers-types\").Request} request\n\t * @param {{UUID: string, PROXYIP: string, DNS_RESOLVER_URL: string, NODE_ID: int, API_HOST: string, API_TOKEN: string}} env\n\t * @param {import(\"@cloudflare/workers-types\").ExecutionContext} ctx\n\t * @returns {Promise<Response>}\n\t */\n\tasync fetch(request, env, ctx) {\n\t\ttry {\n\t\t\tuserID = env.UUID || userID;\n\t\t\tproxyIP = env.PROXYIP || proxyIP;\n\t\t\tdohURL = env.DNS_RESOLVER_URL || dohURL;\n\t\t\tnodeId = env.NODE_ID || nodeId;\n\t\t\tapiToken = env.API_TOKEN || apiToken;\n\t\t\tapiHost = env.API_HOST || apiHost;\n\t\t\tlet userID_Path = userID;\n\t\t\tif (userID.includes(',')) {\n\t\t\t\tuserID_Path = userID.split(',')[0];\n\t\t\t}\n\t\t\tconst upgradeHeader = request.headers.get('Upgrade');\n\t\t\tif (!upgradeHeader || upgradeHeader !== 'websocket') {\n\t\t\t\tconst url = new URL(request.url);\n\t\t\t\tswitch (url.pathname) {\n\t\t\t\t\tcase '/cf':\n\t\t\t\t\t\treturn new Response(JSON.stringify(request.cf, null, 4), {\n\t\t\t\t\t\t\tstatus: 200,\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t\"Content-Type\": \"application/json;charset=utf-8\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\tcase '/connect': // for test connect to cf socket\n\t\t\t\t\t\tconst [hostname, port] = ['cloudflare.com', '80'];\n\t\t\t\t\t\tconsole.log(`Connecting to ${hostname}:${port}...`);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst socket = await connect({\n\t\t\t\t\t\t\t\thostname: hostname,\n\t\t\t\t\t\t\t\tport: parseInt(port, 10),\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tconst writer = socket.writable.getWriter();\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait writer.write(new TextEncoder().encode('GET / HTTP/1.1\\r\\nHost: ' + hostname + '\\r\\n\\r\\n'));\n\t\t\t\t\t\t\t} catch (writeError) {\n\t\t\t\t\t\t\t\twriter.releaseLock();\n\t\t\t\t\t\t\t\tawait socket.close();\n\t\t\t\t\t\t\t\treturn new Response(writeError.message, { status: 500 });\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twriter.releaseLock();\n\n\t\t\t\t\t\t\tconst reader = socket.readable.getReader();\n\t\t\t\t\t\t\tlet value;\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconst result = await reader.read();\n\t\t\t\t\t\t\t\tvalue = result.value;\n\t\t\t\t\t\t\t} catch (readError) {\n\t\t\t\t\t\t\t\tawait reader.releaseLock();\n\t\t\t\t\t\t\t\tawait socket.close();\n\t\t\t\t\t\t\t\treturn new Response(readError.message, { status: 500 });\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tawait reader.releaseLock();\n\t\t\t\t\t\t\tawait socket.close();\n\n\t\t\t\t\t\t\treturn new Response(new TextDecoder().decode(value), { status: 200 });\n\t\t\t\t\t\t} catch (connectError) {\n\t\t\t\t\t\t\treturn new Response(connectError.message, { status: 500 });\n\t\t\t\t\t\t}\n\t\t\t\t\tcase `/${userID_Path}`: {\n\t\t\t\t\t\tconst vlessConfig = getVLESSConfig(userID, request.headers.get('Host'));\n\t\t\t\t\t\treturn new Response(`${vlessConfig}`, {\n\t\t\t\t\t\t\tstatus: 200,\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t\"Content-Type\": \"text/html; charset=utf-8\",\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tcase `/sub/${userID_Path}`: {\n\t\t\t\t\t\tconst url = new URL(request.url);\n\t\t\t\t\t\tconst searchParams = url.searchParams;\n\t\t\t\t\t\tlet vlessConfig = createVLESSSub(userID, request.headers.get('Host'));\n\n\t\t\t\t\t\t// If 'format' query param equals to 'clash', convert config to base64\n\t\t\t\t\t\tif (searchParams.get('format') === 'clash') {\n\t\t\t\t\t\t\tvlessConfig = btoa(vlessConfig);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Construct and return response object\n\t\t\t\t\t\treturn new Response(vlessConfig, {\n\t\t\t\t\t\t\tstatus: 200,\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t\"Content-Type\": \"text/plain;charset=utf-8\",\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tcase `/subscribe/${userID_Path}`: {\n\t\t\t\t\t\tconst url = new URL(request.url);\n\t\t\t\t\t\tconst searchParams = url.searchParams;\n\t\t\t\t\t\tlet vlessConfig = await createVLESSSubByOptimizationIp(userID, request.headers.get('Host'));\n\n\t\t\t\t\t\t// If 'format' query param equals to 'clash', convert config to base64\n\t\t\t\t\t\tif (searchParams.get('format') === 'clash') {\n\t\t\t\t\t\t\tvlessConfig = btoa(vlessConfig);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Construct and return response object\n\t\t\t\t\t\treturn new Response(vlessConfig, {\n\t\t\t\t\t\t\tstatus: 200,\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t\"Content-Type\": \"text/plain;charset=utf-8\",\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// return new Response('Not found', { status: 404 });\n\t\t\t\t\t\t// For any other path, reverse proxy to 'www.fmprc.gov.cn' and return the original response, caching it in the process\n\t\t\t\t\t\tconst hostnames = ['www.fmprc.gov.cn', 'www.xuexi.cn', 'www.gov.cn', 'mail.gov.cn', 'www.mofcom.gov.cn', 'www.gfbzb.gov.cn', 'www.miit.gov.cn', 'www.12377.cn'];\n\t\t\t\t\t\turl.hostname = hostnames[Math.floor(Math.random() * hostnames.length)];\n\t\t\t\t\t\turl.protocol = 'https:';\n\t\t\t\t\t\tconst newHeaders = new Headers(request.headers);\n\t\t\t\t\t\tnewHeaders.set('cf-connecting-ip', newHeaders.get('x-forwarded-for') || newHeaders.get('cf-connecting-ip'));\n\t\t\t\t\t\tnewHeaders.set('x-forwarded-for', newHeaders.get('cf-connecting-ip'));\n\t\t\t\t\t\tnewHeaders.set('x-real-ip', newHeaders.get('cf-connecting-ip'));\n\t\t\t\t\t\tnewHeaders.set('referer', 'https://www.google.com/q=edtunnel');\n\t\t\t\t\t\trequest = new Request(url, {\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\theaders: newHeaders,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tredirect: request.redirect,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst cache = caches.default;\n\t\t\t\t\t\tlet response = await cache.match(request);\n\t\t\t\t\t\tif (!response) {\n\t\t\t\t\t\t\t// if not in cache, get response from origin\n\t\t\t\t\t\t\t// send client ip to origin server to get right ip\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = await fetch(request, { redirect: \"manual\" });\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\turl.protocol = 'http:';\n\t\t\t\t\t\t\t\turl.hostname = hostnames[Math.floor(Math.random() * hostnames.length)];\n\t\t\t\t\t\t\t\trequest = new Request(url, {\n\t\t\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\t\t\theaders: newHeaders,\n\t\t\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\t\t\tredirect: request.redirect,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tresponse = await fetch(request, { redirect: \"manual\" });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst cloneResponse = response.clone();\n\t\t\t\t\t\t\tctx.waitUntil(cache.put(request, cloneResponse));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn response;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn await vlessOverWSHandler(request);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t/** @type {Error} */ let e = err;\n\t\t\treturn new Response(e.toString());\n\t\t}\n\t},\n};\n\n/**\n * Creates a PlanetScale connection object and returns it.\n * @param {{DATABASE_HOST: string, DATABASE_USERNAME: string, DATABASE_PASSWORD: string}} env The environment variables containing the database connection information.\n * @returns {Promise<object>} A Promise that resolves to the PlanetScale connection object.\n */\nfunction getPlanetScaleConnection(env) {\n\tconst config = {\n\t\thost: env.DATABASE_HOST,\n\t\tusername: env.DATABASE_USERNAME,\n\t\tpassword: env.DATABASE_PASSWORD,\n\t\tfetch: (url, init) => {\n\t\t\tdelete (init)[\"cache\"];\n\t\t\treturn fetch(url, init);\n\t\t}\n\t}\n\treturn connectdb(config)\n}\n\n/**\n * Handles VLESS over WebSocket requests by creating a WebSocket pair, accepting the WebSocket connection, and processing the VLESS header.\n * @param {import(\"@cloudflare/workers-types\").Request} request The incoming request object.\n * @returns {Promise<Response>} A Promise that resolves to a WebSocket response object.\n */\nasync function vlessOverWSHandler(request) {\n\tconst webSocketPair = new WebSocketPair();\n\tconst [client, webSocket] = Object.values(webSocketPair);\n\twebSocket.accept();\n\n\tlet address = '';\n\tlet portWithRandomLog = '';\n\tconst log = (/** @type {string} */ info, /** @type {string | undefined} */ event) => {\n\t\tconsole.log(`[${address}:${portWithRandomLog}] ${info}`, event || '');\n\t};\n\tconst earlyDataHeader = request.headers.get('sec-websocket-protocol') || '';\n\n\tconst readableWebSocketStream = makeReadableWebSocketStream(webSocket, earlyDataHeader, log);\n\n\t/** @type {{ value: import(\"@cloudflare/workers-types\").Socket | null}}*/\n\tlet remoteSocketWapper = {\n\t\tvalue: null,\n\t};\n\tlet udpStreamWrite = null;\n\tlet isDns = false;\n\n\t// ws --> remote\n\treadableWebSocketStream.pipeTo(new WritableStream({\n\t\tasync write(chunk, controller) {\n\t\t\tif (isDns && udpStreamWrite) {\n\t\t\t\treturn udpStreamWrite(chunk);\n\t\t\t}\n\t\t\tif (remoteSocketWapper.value) {\n\t\t\t\tconst writer = remoteSocketWapper.value.writable.getWriter()\n\t\t\t\tawait writer.write(chunk);\n\t\t\t\twriter.releaseLock();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\thasError,\n\t\t\t\tmessage,\n\t\t\t\tportRemote = 443,\n\t\t\t\taddressRemote = '',\n\t\t\t\trawDataIndex,\n\t\t\t\tvlessVersion = new Uint8Array([0, 0]),\n\t\t\t\tisUDP,\n\t\t\t} = processVlessHeader(chunk, userID);\n\t\t\taddress = addressRemote;\n\t\t\tportWithRandomLog = `${portRemote} ${isUDP ? 'udp' : 'tcp'} `;\n\t\t\tif (hasError) {\n\t\t\t\t// controller.error(message);\n\t\t\t\tthrow new Error(message); // cf seems has bug, controller.error will not end stream\n\t\t\t\t// webSocket.close(1000, message);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If UDP and not DNS port, close it\n\t\t\tif (isUDP && portRemote !== 53) {\n\t\t\t\tthrow new Error('UDP proxy only enabled for DNS which is port 53');\n\t\t\t\t// cf seems has bug, controller.error will not end stream\n\t\t\t}\n\n\t\t\tif (isUDP && portRemote === 53) {\n\t\t\t\tisDns = true;\n\t\t\t}\n\n\t\t\t// [\"version\", \"\u9644\u52A0\u4FE1\u606F\u957F\u5EA6 N\"]\n\t\t\tconst vlessResponseHeader = new Uint8Array([vlessVersion[0], 0]);\n\t\t\tconst rawClientData = chunk.slice(rawDataIndex);\n\n\t\t\t// TODO: support udp here when cf runtime has udp support\n\t\t\tif (isDns) {\n\t\t\t\tconst { write } = await handleUDPOutBound(webSocket, vlessResponseHeader, log);\n\t\t\t\tudpStreamWrite = write;\n\t\t\t\tudpStreamWrite(rawClientData);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\thandleTCPOutBound(remoteSocketWapper, addressRemote, portRemote, rawClientData, webSocket, vlessResponseHeader, log);\n\t\t},\n\t\tclose() {\n\t\t\tlog(`readableWebSocketStream is close`);\n\t\t},\n\t\tabort(reason) {\n\t\t\tlog(`readableWebSocketStream is abort`, JSON.stringify(reason));\n\t\t},\n\t})).catch((err) => {\n\t\tlog('readableWebSocketStream pipeTo error', err);\n\t});\n\n\treturn new Response(null, {\n\t\tstatus: 101,\n\t\twebSocket: client,\n\t});\n}\n\nlet apiResponseCache = null;\nlet cacheTimeout = null;\n\n/**\n * Fetches the API response from the server and caches it for future use.\n * @returns {Promise<object|null>} A Promise that resolves to the API response object or null if there was an error.\n */\nasync function fetchApiResponse() {\n\tconst requestOptions = {\n\t\tmethod: 'GET',\n\t\tredirect: 'follow'\n\t};\n\n\ttry {\n\t\tconst response = await fetch(`https://${apiHost}/api/v1/server/UniProxy/user?node_id=${nodeId}&node_type=v2ray&token=${apiToken}`, requestOptions);\n\n\t\tif (!response.ok) {\n\t\t\tconsole.error('Error: Network response was not ok');\n\t\t\treturn null;\n\t\t}\n\t\tconst apiResponse = await response.json();\n\t\tapiResponseCache = apiResponse;\n\n\t\t// Refresh the cache every 5 minutes (300000 milliseconds)\n\t\tif (cacheTimeout) {\n\t\t\tclearTimeout(cacheTimeout);\n\t\t}\n\t\tcacheTimeout = setTimeout(() => fetchApiResponse(), 300000);\n\n\t\treturn apiResponse;\n\t} catch (error) {\n\t\tconsole.error('Error:', error);\n\t\treturn null;\n\t}\n}\n\n/**\n * Returns the cached API response if it exists, otherwise fetches the API response from the server and caches it for future use.\n * @returns {Promise<object|null>} A Promise that resolves to the cached API response object or the fetched API response object, or null if there was an error.\n */\nasync function getApiResponse() {\n\tif (!apiResponseCache) {\n\t\treturn await fetchApiResponse();\n\t}\n\treturn apiResponseCache;\n}\n\n/**\n * Checks if a given UUID is present in the API response.\n * @param {string} targetUuid The UUID to search for.\n * @returns {Promise<boolean>} A Promise that resolves to true if the UUID is present in the API response, false otherwise.\n */\nasync function checkUuidInApiResponse(targetUuid) {\n\t// Check if any of the environment variables are empty\n\tif (!nodeId || !apiToken || !apiHost) {\n\t\treturn false;\n\t}\n\n\ttry {\n\t\tconst apiResponse = await getApiResponse();\n\t\tif (!apiResponse) {\n\t\t\treturn false;\n\t\t}\n\t\tconst isUuidInResponse = apiResponse.users.some(user => user.uuid === targetUuid);\n\t\treturn isUuidInResponse;\n\t} catch (error) {\n\t\tconsole.error('Error:', error);\n\t\treturn false;\n\t}\n}\n\n// Usage example:\n//   const targetUuid = \"65590e04-a94c-4c59-a1f2-571bce925aad\";\n//   checkUuidInApiResponse(targetUuid).then(result => console.log(result));\n\n/**\n * Handles outbound TCP connections.\n *\n * @param {any} remoteSocket \n * @param {string} addressRemote The remote address to connect to.\n * @param {number} portRemote The remote port to connect to.\n * @param {Uint8Array} rawClientData The raw client data to write.\n * @param {import(\"@cloudflare/workers-types\").WebSocket} webSocket The WebSocket to pass the remote socket to.\n * @param {Uint8Array} vlessResponseHeader The VLESS response header.\n * @param {function} log The logging function.\n * @returns {Promise<void>} The remote socket.\n */\nasync function handleTCPOutBound(remoteSocket, addressRemote, portRemote, rawClientData, webSocket, vlessResponseHeader, log,) {\n\n\t/**\n\t * Connects to a given address and port and writes data to the socket.\n\t * @param {string} address The address to connect to.\n\t * @param {number} port The port to connect to.\n\t * @returns {Promise<import(\"@cloudflare/workers-types\").Socket>} A Promise that resolves to the connected socket.\n\t */\n\tasync function connectAndWrite(address, port) {\n\t\t/** @type {import(\"@cloudflare/workers-types\").Socket} */\n\t\tconst tcpSocket = connect({\n\t\t\thostname: address,\n\t\t\tport: port,\n\t\t});\n\t\tremoteSocket.value = tcpSocket;\n\t\tlog(`connected to ${address}:${port}`);\n\t\tconst writer = tcpSocket.writable.getWriter();\n\t\tawait writer.write(rawClientData); // first write, nomal is tls client hello\n\t\twriter.releaseLock();\n\t\treturn tcpSocket;\n\t}\n\n\t/**\n\t * Retries connecting to the remote address and port if the Cloudflare socket has no incoming data.\n\t * @returns {Promise<void>} A Promise that resolves when the retry is complete.\n\t */\n\tasync function retry() {\n\t\tconst tcpSocket = await connectAndWrite(proxyIP || addressRemote, portRemote)\n\t\ttcpSocket.closed.catch(error => {\n\t\t\tconsole.log('retry tcpSocket closed error', error);\n\t\t}).finally(() => {\n\t\t\tsafeCloseWebSocket(webSocket);\n\t\t})\n\t\tremoteSocketToWS(tcpSocket, webSocket, vlessResponseHeader, null, log);\n\t}\n\n\tconst tcpSocket = await connectAndWrite(addressRemote, portRemote);\n\n\t// when remoteSocket is ready, pass to websocket\n\t// remote--> ws\n\tremoteSocketToWS(tcpSocket, webSocket, vlessResponseHeader, retry, log);\n}\n\n/**\n * Creates a readable stream from a WebSocket server, allowing for data to be read from the WebSocket.\n * @param {import(\"@cloudflare/workers-types\").WebSocket} webSocketServer The WebSocket server to create the readable stream from.\n * @param {string} earlyDataHeader The header containing early data for WebSocket 0-RTT.\n * @param {(info: string)=> void} log The logging function.\n * @returns {ReadableStream} A readable stream that can be used to read data from the WebSocket.\n */\nfunction makeReadableWebSocketStream(webSocketServer, earlyDataHeader, log) {\n\tlet readableStreamCancel = false;\n\tconst stream = new ReadableStream({\n\t\tstart(controller) {\n\t\t\twebSocketServer.addEventListener('message', (event) => {\n\t\t\t\tconst message = event.data;\n\t\t\t\tcontroller.enqueue(message);\n\t\t\t});\n\n\t\t\twebSocketServer.addEventListener('close', () => {\n\t\t\t\tsafeCloseWebSocket(webSocketServer);\n\t\t\t\tcontroller.close();\n\t\t\t});\n\n\t\t\twebSocketServer.addEventListener('error', (err) => {\n\t\t\t\tlog('webSocketServer has error');\n\t\t\t\tcontroller.error(err);\n\t\t\t});\n\t\t\tconst { earlyData, error } = base64ToArrayBuffer(earlyDataHeader);\n\t\t\tif (error) {\n\t\t\t\tcontroller.error(error);\n\t\t\t} else if (earlyData) {\n\t\t\t\tcontroller.enqueue(earlyData);\n\t\t\t}\n\t\t},\n\n\t\tpull(controller) {\n\t\t\t// if ws can stop read if stream is full, we can implement backpressure\n\t\t\t// https://streams.spec.whatwg.org/#example-rs-push-backpressure\n\t\t},\n\n\t\tcancel(reason) {\n\t\t\tlog(`ReadableStream was canceled, due to ${reason}`)\n\t\t\treadableStreamCancel = true;\n\t\t\tsafeCloseWebSocket(webSocketServer);\n\t\t}\n\t});\n\n\treturn stream;\n}\n\n// https://xtls.github.io/development/protocols/vless.html\n// https://github.com/zizifn/excalidraw-backup/blob/main/v2ray-protocol.excalidraw\n\n/**\n * Processes the VLESS header buffer and returns an object with the relevant information.\n * @param {ArrayBuffer} vlessBuffer The VLESS header buffer to process.\n * @param {string} userID The user ID to validate against the UUID in the VLESS header.\n * @returns {{\n *  hasError: boolean,\n *  message?: string,\n *  addressRemote?: string,\n *  addressType?: number,\n *  portRemote?: number,\n *  rawDataIndex?: number,\n *  vlessVersion?: Uint8Array,\n *  isUDP?: boolean\n * }} An object with the relevant information extracted from the VLESS header buffer.\n */\nfunction processVlessHeader(vlessBuffer, userID) {\n\tif (vlessBuffer.byteLength < 24) {\n\t\treturn {\n\t\t\thasError: true,\n\t\t\tmessage: 'invalid data',\n\t\t};\n\t}\n\tconst version = new Uint8Array(vlessBuffer.slice(0, 1));\n\tlet isValidUser = false;\n\tlet isUDP = false;\n\tconst slicedBuffer = new Uint8Array(vlessBuffer.slice(1, 17));\n\tconst slicedBufferString = stringify(slicedBuffer);\n\t// check if userID is valid uuid or uuids split by , and contains userID in it otherwise return error message to console\n\tconst uuids = userID.includes(',') ? userID.split(\",\") : [userID];\n\tconsole.log(slicedBufferString, uuids);\n\n\t// isValidUser = uuids.some(userUuid => slicedBufferString === userUuid.trim());\n\tisValidUser = uuids.some(userUuid => slicedBufferString === userUuid.trim()) || uuids.length === 1 && slicedBufferString === uuids[0].trim();\n\n\tconsole.log(`userID: ${slicedBufferString}`);\n\n\tif (!isValidUser) {\n\t\treturn {\n\t\t\thasError: true,\n\t\t\tmessage: 'invalid user',\n\t\t};\n\t}\n\n\tconst optLength = new Uint8Array(vlessBuffer.slice(17, 18))[0];\n\t//skip opt for now\n\n\tconst command = new Uint8Array(\n\t\tvlessBuffer.slice(18 + optLength, 18 + optLength + 1)\n\t)[0];\n\n\t// 0x01 TCP\n\t// 0x02 UDP\n\t// 0x03 MUX\n\tif (command === 1) {\n\t\tisUDP = false;\n\t} else if (command === 2) {\n\t\tisUDP = true;\n\t} else {\n\t\treturn {\n\t\t\thasError: true,\n\t\t\tmessage: `command ${command} is not support, command 01-tcp,02-udp,03-mux`,\n\t\t};\n\t}\n\tconst portIndex = 18 + optLength + 1;\n\tconst portBuffer = vlessBuffer.slice(portIndex, portIndex + 2);\n\t// port is big-Endian in raw data etc 80 == 0x005d\n\tconst portRemote = new DataView(portBuffer).getUint16(0);\n\n\tlet addressIndex = portIndex + 2;\n\tconst addressBuffer = new Uint8Array(\n\t\tvlessBuffer.slice(addressIndex, addressIndex + 1)\n\t);\n\n\t// 1--> ipv4  addressLength =4\n\t// 2--> domain name addressLength=addressBuffer[1]\n\t// 3--> ipv6  addressLength =16\n\tconst addressType = addressBuffer[0];\n\tlet addressLength = 0;\n\tlet addressValueIndex = addressIndex + 1;\n\tlet addressValue = '';\n\tswitch (addressType) {\n\t\tcase 1:\n\t\t\taddressLength = 4;\n\t\t\taddressValue = new Uint8Array(\n\t\t\t\tvlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength)\n\t\t\t).join('.');\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\taddressLength = new Uint8Array(\n\t\t\t\tvlessBuffer.slice(addressValueIndex, addressValueIndex + 1)\n\t\t\t)[0];\n\t\t\taddressValueIndex += 1;\n\t\t\taddressValue = new TextDecoder().decode(\n\t\t\t\tvlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\taddressLength = 16;\n\t\t\tconst dataView = new DataView(\n\t\t\t\tvlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength)\n\t\t\t);\n\t\t\t// 2001:0db8:85a3:0000:0000:8a2e:0370:7334\n\t\t\tconst ipv6 = [];\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tipv6.push(dataView.getUint16(i * 2).toString(16));\n\t\t\t}\n\t\t\taddressValue = ipv6.join(':');\n\t\t\t// seems no need add [] for ipv6\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn {\n\t\t\t\thasError: true,\n\t\t\t\tmessage: `invild  addressType is ${addressType}`,\n\t\t\t};\n\t}\n\tif (!addressValue) {\n\t\treturn {\n\t\t\thasError: true,\n\t\t\tmessage: `addressValue is empty, addressType is ${addressType}`,\n\t\t};\n\t}\n\n\treturn {\n\t\thasError: false,\n\t\taddressRemote: addressValue,\n\t\taddressType,\n\t\tportRemote,\n\t\trawDataIndex: addressValueIndex + addressLength,\n\t\tvlessVersion: version,\n\t\tisUDP,\n\t};\n}\n\n\n/**\n * Converts a remote socket to a WebSocket connection.\n * @param {import(\"@cloudflare/workers-types\").Socket} remoteSocket The remote socket to convert.\n * @param {import(\"@cloudflare/workers-types\").WebSocket} webSocket The WebSocket to connect to.\n * @param {ArrayBuffer | null} vlessResponseHeader The VLESS response header.\n * @param {(() => Promise<void>) | null} retry The function to retry the connection if it fails.\n * @param {(info: string) => void} log The logging function.\n * @returns {Promise<void>} A Promise that resolves when the conversion is complete.\n */\nasync function remoteSocketToWS(remoteSocket, webSocket, vlessResponseHeader, retry, log) {\n\t// remote--> ws\n\tlet remoteChunkCount = 0;\n\tlet chunks = [];\n\t/** @type {ArrayBuffer | null} */\n\tlet vlessHeader = vlessResponseHeader;\n\tlet hasIncomingData = false; // check if remoteSocket has incoming data\n\tawait remoteSocket.readable\n\t\t.pipeTo(\n\t\t\tnew WritableStream({\n\t\t\t\tstart() {\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * \n\t\t\t\t * @param {Uint8Array} chunk \n\t\t\t\t * @param {*} controller \n\t\t\t\t */\n\t\t\t\tasync write(chunk, controller) {\n\t\t\t\t\thasIncomingData = true;\n\t\t\t\t\tremoteChunkCount++;\n\t\t\t\t\tif (webSocket.readyState !== WS_READY_STATE_OPEN) {\n\t\t\t\t\t\tcontroller.error(\n\t\t\t\t\t\t\t'webSocket.readyState is not open, maybe close'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (vlessHeader) {\n\t\t\t\t\t\twebSocket.send(await new Blob([vlessHeader, chunk]).arrayBuffer());\n\t\t\t\t\t\tvlessHeader = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(`remoteSocketToWS send chunk ${chunk.byteLength}`);\n\t\t\t\t\t\t// seems no need rate limit this, CF seems fix this??..\n\t\t\t\t\t\t// if (remoteChunkCount > 20000) {\n\t\t\t\t\t\t// \t// cf one package is 4096 byte(4kb),  4096 * 20000 = 80M\n\t\t\t\t\t\t// \tawait delay(1);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\twebSocket.send(chunk);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tclose() {\n\t\t\t\t\tlog(`remoteConnection!.readable is close with hasIncomingData is ${hasIncomingData}`);\n\t\t\t\t\t// safeCloseWebSocket(webSocket); // no need server close websocket frist for some case will casue HTTP ERR_CONTENT_LENGTH_MISMATCH issue, client will send close event anyway.\n\t\t\t\t},\n\t\t\t\tabort(reason) {\n\t\t\t\t\tconsole.error(`remoteConnection!.readable abort`, reason);\n\t\t\t\t},\n\t\t\t})\n\t\t)\n\t\t.catch((error) => {\n\t\t\tconsole.error(\n\t\t\t\t`remoteSocketToWS has exception `,\n\t\t\t\terror.stack || error\n\t\t\t);\n\t\t\tsafeCloseWebSocket(webSocket);\n\t\t});\n\n\t// seems is cf connect socket have error,\n\t// 1. Socket.closed will have error\n\t// 2. Socket.readable will be close without any data coming\n\tif (hasIncomingData === false && retry) {\n\t\tlog(`retry`)\n\t\tretry();\n\t}\n}\n\n/**\n * Decodes a base64 string into an ArrayBuffer.\n * @param {string} base64Str The base64 string to decode.\n * @returns {{earlyData: ArrayBuffer|null, error: Error|null}} An object containing the decoded ArrayBuffer or null if there was an error, and any error that occurred during decoding or null if there was no error.\n */\nfunction base64ToArrayBuffer(base64Str) {\n\tif (!base64Str) {\n\t\treturn { earlyData: null, error: null };\n\t}\n\ttry {\n\t\t// go use modified Base64 for URL rfc4648 which js atob not support\n\t\tbase64Str = base64Str.replace(/-/g, '+').replace(/_/g, '/');\n\t\tconst decode = atob(base64Str);\n\t\tconst arryBuffer = Uint8Array.from(decode, (c) => c.charCodeAt(0));\n\t\treturn { earlyData: arryBuffer.buffer, error: null };\n\t} catch (error) {\n\t\treturn { earlyData: null, error };\n\t}\n}\n\n/**\n * Checks if a given string is a valid UUID.\n * Note: This is not a real UUID validation.\n * @param {string} uuid The string to validate as a UUID.\n * @returns {boolean} True if the string is a valid UUID, false otherwise.\n */\nfunction isValidUUID(uuid) {\n\tconst uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\treturn uuidRegex.test(uuid);\n}\n\nconst WS_READY_STATE_OPEN = 1;\nconst WS_READY_STATE_CLOSING = 2;\n/**\n * Closes a WebSocket connection safely without throwing exceptions.\n * @param {import(\"@cloudflare/workers-types\").WebSocket} socket The WebSocket connection to close.\n */\nfunction safeCloseWebSocket(socket) {\n\ttry {\n\t\tif (socket.readyState === WS_READY_STATE_OPEN || socket.readyState === WS_READY_STATE_CLOSING) {\n\t\t\tsocket.close();\n\t\t}\n\t} catch (error) {\n\t\tconsole.error('safeCloseWebSocket error', error);\n\t}\n}\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n\tbyteToHex.push((i + 256).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n\treturn (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \"-\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \"-\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \"-\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \"-\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\nfunction stringify(arr, offset = 0) {\n\tconst uuid = unsafeStringify(arr, offset);\n\tif (!isValidUUID(uuid)) {\n\t\tthrow TypeError(\"Stringified UUID is invalid\");\n\t}\n\treturn uuid;\n}\n\n\n/**\n * Handles outbound UDP traffic by transforming the data into DNS queries and sending them over a WebSocket connection.\n * @param {import(\"@cloudflare/workers-types\").WebSocket} webSocket The WebSocket connection to send the DNS queries over.\n * @param {ArrayBuffer} vlessResponseHeader The VLESS response header.\n * @param {(string) => void} log The logging function.\n * @returns {{write: (chunk: Uint8Array) => void}} An object with a write method that accepts a Uint8Array chunk to write to the transform stream.\n */\nasync function handleUDPOutBound(webSocket, vlessResponseHeader, log) {\n\n\tlet isVlessHeaderSent = false;\n\tconst transformStream = new TransformStream({\n\t\tstart(controller) {\n\n\t\t},\n\t\ttransform(chunk, controller) {\n\t\t\t// udp message 2 byte is the the length of udp data\n\t\t\t// TODO: this should have bug, beacsue maybe udp chunk can be in two websocket message\n\t\t\tfor (let index = 0; index < chunk.byteLength;) {\n\t\t\t\tconst lengthBuffer = chunk.slice(index, index + 2);\n\t\t\t\tconst udpPakcetLength = new DataView(lengthBuffer).getUint16(0);\n\t\t\t\tconst udpData = new Uint8Array(\n\t\t\t\t\tchunk.slice(index + 2, index + 2 + udpPakcetLength)\n\t\t\t\t);\n\t\t\t\tindex = index + 2 + udpPakcetLength;\n\t\t\t\tcontroller.enqueue(udpData);\n\t\t\t}\n\t\t},\n\t\tflush(controller) {\n\t\t}\n\t});\n\n\t// only handle dns udp for now\n\ttransformStream.readable.pipeTo(new WritableStream({\n\t\tasync write(chunk) {\n\t\t\tconst resp = await fetch(dohURL, // dns server url\n\t\t\t\t{\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/dns-message',\n\t\t\t\t\t},\n\t\t\t\t\tbody: chunk,\n\t\t\t\t})\n\t\t\tconst dnsQueryResult = await resp.arrayBuffer();\n\t\t\tconst udpSize = dnsQueryResult.byteLength;\n\t\t\t// console.log([...new Uint8Array(dnsQueryResult)].map((x) => x.toString(16)));\n\t\t\tconst udpSizeBuffer = new Uint8Array([(udpSize >> 8) & 0xff, udpSize & 0xff]);\n\t\t\tif (webSocket.readyState === WS_READY_STATE_OPEN) {\n\t\t\t\tlog(`doh success and dns message length is ${udpSize}`);\n\t\t\t\tif (isVlessHeaderSent) {\n\t\t\t\t\twebSocket.send(await new Blob([udpSizeBuffer, dnsQueryResult]).arrayBuffer());\n\t\t\t\t} else {\n\t\t\t\t\twebSocket.send(await new Blob([vlessResponseHeader, udpSizeBuffer, dnsQueryResult]).arrayBuffer());\n\t\t\t\t\tisVlessHeaderSent = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})).catch((error) => {\n\t\tlog('dns udp has error' + error)\n\t});\n\n\tconst writer = transformStream.writable.getWriter();\n\n\treturn {\n\t\t/**\n\t\t * \n\t\t * @param {Uint8Array} chunk \n\t\t */\n\t\twrite(chunk) {\n\t\t\twriter.write(chunk);\n\t\t}\n\t};\n}\n\n/**\n *\n * @param {string} userID - single or comma separated userIDs\n * @param {string | null} hostName\n * @returns {string}\n */\nfunction getVLESSConfig(userIDs, hostName) {\n\tconst commonUrlPart = `:443?encryption=none&security=tls&sni=${hostName}&fp=randomized&type=ws&host=${hostName}&path=%2F%3Fed%3D2048#${hostName}`;\n\tconst separator = \"---------------------------------------------------------------\";\n\tconst hashSeparator = \"################################################################\";\n\n\t// Split the userIDs into an array\n\tlet userIDArray = userIDs.split(',');\n\n\t// Prepare output array\n\tlet output = [];\n\tlet header = [];\n\tconst clash_link = encodeURIComponent(`https://subconverter.do.xn--b6gac.eu.org/sub?target=clash&url=https://${hostName}/sub/${userIDArray[0]}?format=clash&insert=false&emoji=true&list=false&tfo=false&scv=true&fdn=false&sort=false&new_name=true`);\n\theader.push(`\\n<p align=\"center\"><img src=\"https://cloudflare-ipfs.com/ipfs/bafybeigd6i5aavwpr6wvnwuyayklq3omonggta4x2q7kpmgafj357nkcky\" alt=\"\u56FE\u7247\u63CF\u8FF0\" style=\"margin-bottom: -50px;\">`);\n\theader.push(`\\n<b style=\" font-size: 15px;\" >Welcome! This function generates configuration for VLESS protocol. If you found this useful, please check our GitHub project for more:</b>\\n`);\n\theader.push(`<b style=\" font-size: 15px;\" >\u6B22\u8FCE\uFF01\u8FD9\u662F\u751F\u6210 VLESS \u534F\u8BAE\u7684\u914D\u7F6E\u3002\u5982\u679C\u60A8\u53D1\u73B0\u8FD9\u4E2A\u9879\u76EE\u5F88\u597D\u7528\uFF0C\u8BF7\u67E5\u770B\u6211\u4EEC\u7684 GitHub \u9879\u76EE\u7ED9\u6211\u4E00\u4E2Astar\uFF1A</b>\\n`);\n\theader.push(`\\n<a href=\"https://github.com/3Kmfi6HP/EDtunnel\" target=\"_blank\">EDtunnel - https://github.com/3Kmfi6HP/EDtunnel</a>\\n`);\n\theader.push(`\\n<iframe src=\"https://ghbtns.com/github-btn.html?user=USERNAME&repo=REPOSITORY&type=star&count=true&size=large\" frameborder=\"0\" scrolling=\"0\" width=\"170\" height=\"30\" title=\"GitHub\"></iframe>\\n\\n`.replace(/USERNAME/g, \"3Kmfi6HP\").replace(/REPOSITORY/g, \"EDtunnel\"));\n\theader.push(`<a href=\"//${hostName}/sub/${userIDArray[0]}\" target=\"_blank\">VLESS \u8282\u70B9\u8BA2\u9605\u8FDE\u63A5</a>\\n<a href=\"clash://install-config?url=${clash_link}\" target=\"_blank\">Clash \u8282\u70B9\u8BA2\u9605\u8FDE\u63A5</a></p>\\n`);\n\theader.push(``);\n\n\t// Generate output string for each userID\n\tuserIDArray.forEach((userID) => {\n\t\tconst vlessMain = `vless://${userID}@${hostName}${commonUrlPart}`;\n\t\tconst vlessSec = `vless://${userID}@${proxyIP}${commonUrlPart}`;\n\t\toutput.push(`UUID: ${userID}`);\n\t\toutput.push(`${hashSeparator}\\nv2ray default ip\\n${separator}\\n${vlessMain}\\n${separator}`);\n\t\toutput.push(`${hashSeparator}\\nv2ray with best ip\\n${separator}\\n${vlessSec}\\n${separator}`);\n\t});\n\toutput.push(`${hashSeparator}\\n# Clash Proxy Provider \u914D\u7F6E\u683C\u5F0F(configuration format)\\nproxy-groups:\\n  - name: UseProvider\\n\ttype: select\\n\tuse:\\n\t  - provider1\\n\tproxies:\\n\t  - Proxy\\n\t  - DIRECT\\nproxy-providers:\\n  provider1:\\n\ttype: http\\n\turl: https://${hostName}/sub/${userIDArray[0]}?format=clash\\n\tinterval: 3600\\n\tpath: ./provider1.yaml\\n\thealth-check:\\n\t  enable: true\\n\t  interval: 600\\n\t  # lazy: true\\n\t  url: http://www.gstatic.com/generate_204\\n\\n${hashSeparator}`);\n\n\t// HTML Head with CSS\n\tconst htmlHead = `\n    <head>\n        <title>EDtunnel: VLESS configuration</title>\n        <meta name=\"description\" content=\"This is a tool for generating VLESS protocol configurations. Give us a star on GitHub https://github.com/3Kmfi6HP/EDtunnel if you found it useful!\">\n\t\t<meta name=\"keywords\" content=\"EDtunnel, cloudflare pages, cloudflare worker, severless\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\t\t<meta property=\"og:site_name\" content=\"EDtunnel: VLESS configuration\" />\n        <meta property=\"og:type\" content=\"website\" />\n        <meta property=\"og:title\" content=\"EDtunnel - VLESS configuration and subscribe output\" />\n        <meta property=\"og:description\" content=\"Use cloudflare pages and worker severless to implement vless protocol\" />\n        <meta property=\"og:url\" content=\"https://${hostName}/\" />\n        <meta property=\"og:image\" content=\"https://api.qrserver.com/v1/create-qr-code/?size=500x500&data=${encodeURIComponent(`vless://${userIDs.split(',')[0]}@${hostName}${commonUrlPart}`)}\" />\n        <meta name=\"twitter:card\" content=\"summary_large_image\" />\n        <meta name=\"twitter:title\" content=\"EDtunnel - VLESS configuration and subscribe output\" />\n        <meta name=\"twitter:description\" content=\"Use cloudflare pages and worker severless to implement vless protocol\" />\n        <meta name=\"twitter:url\" content=\"https://${hostName}/\" />\n        <meta name=\"twitter:image\" content=\"https://cloudflare-ipfs.com/ipfs/bafybeigd6i5aavwpr6wvnwuyayklq3omonggta4x2q7kpmgafj357nkcky\" />\n        <meta property=\"og:image:width\" content=\"1500\" />\n        <meta property=\"og:image:height\" content=\"1500\" />\n\n        <style>\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f0f0f0;\n            color: #333;\n            padding: 10px;\n        }\n\n        a {\n            color: #1a0dab;\n            text-decoration: none;\n        }\n\t\timg {\n\t\t\tmax-width: 100%;\n\t\t\theight: auto;\n\t\t}\n\t\t\n        pre {\n            white-space: pre-wrap;\n            word-wrap: break-word;\n            background-color: #fff;\n            border: 1px solid #ddd;\n            padding: 15px;\n            margin: 10px 0;\n        }\n\t\t/* Dark mode */\n        @media (prefers-color-scheme: dark) {\n            body {\n                background-color: #333;\n                color: #f0f0f0;\n            }\n\n            a {\n                color: #9db4ff;\n            }\n\n            pre {\n                background-color: #282a36;\n                border-color: #6272a4;\n            }\n        }\n        </style>\n    </head>\n    `;\n\n\t// Join output with newlines, wrap inside <html> and <body>\n\treturn `\n    <html>\n    ${htmlHead}\n    <body>\n    <pre style=\"\n    background-color: transparent;\n    border: none;\n\">${header.join('')}</pre><pre>${output.join('\\n')}</pre>\n    </body>\n</html>`;\n}\n\n\nfunction createVLESSSub(userID_Path, hostName) {\n\tlet portArray_http = [80, 8080, 8880, 2052, 2086, 2095];\n\tlet portArray_https = [443, 8443, 2053, 2096, 2087, 2083];\n\n\t// Split the userIDs into an array\n\tlet userIDArray = userID_Path.includes(',') ? userID_Path.split(',') : [userID_Path];\n\n\t// Prepare output array\n\tlet output = [];\n\n\t// Generate output string for each userID\n\tuserIDArray.forEach((userID) => {\n\t\t// Check if the hostName is a Cloudflare Pages domain, if not, generate HTTP configurations\n\t\t// reasons: pages.dev not support http only https\n\t\tif (!hostName.includes('pages.dev')) {\n\t\t\t// Iterate over all ports for http\n\t\t\tportArray_http.forEach((port) => {\n\t\t\t\tconst commonUrlPart_http = `:${port}?encryption=none&security=none&fp=random&type=ws&host=${hostName}&path=%2F%3Fed%3D2048#${hostName}-HTTP`;\n\t\t\t\tconst vlessMainHttp = `vless://${userID}@${hostName}${commonUrlPart_http}`;\n\n\t\t\t\t// For each proxy IP, generate a VLESS configuration and add to output\n\t\t\t\tproxyIPs.forEach((proxyIP) => {\n\t\t\t\t\tconst vlessSecHttp = `vless://${userID}@${proxyIP}${commonUrlPart_http}-${proxyIP}-EDtunnel`;\n\t\t\t\t\toutput.push(`${vlessMainHttp}`);\n\t\t\t\t\toutput.push(`${vlessSecHttp}`);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// Iterate over all ports for https\n\t\tportArray_https.forEach((port) => {\n\t\t\tconst commonUrlPart_https = `:${port}?encryption=none&security=tls&sni=${hostName}&fp=random&type=ws&host=${hostName}&path=%2F%3Fed%3D2048#${hostName}-HTTPS`;\n\t\t\tconst vlessMainHttps = `vless://${userID}@${hostName}${commonUrlPart_https}`;\n\n\t\t\t// For each proxy IP, generate a VLESS configuration and add to output\n\t\t\tproxyIPs.forEach((proxyIP) => {\n\t\t\t\tconst vlessSecHttps = `vless://${userID}@${proxyIP}${commonUrlPart_https}-${proxyIP}-EDtunnel`;\n\t\t\t\toutput.push(`${vlessMainHttps}`);\n\t\t\t\toutput.push(`${vlessSecHttps}`);\n\t\t\t});\n\t\t});\n\t});\n\n\t// Join output with newlines\n\treturn output.join('\\n');\n}\n\nasync function createVLESSSubByOptimizationIp(userID_Path, hostName) {\n\t// let portArray_http = [80, 8080, 8880, 2052, 2086, 2095];\n\t// let portArray_https = [443, 8443, 2053, 2096, 2087, 2083];\n\tlet portArray_http = [];\n\tlet portArray_https = [443, 2096];\n\n\t// Split the userIDs into an array\n\tlet userIDArray = userID_Path.includes(',') ? userID_Path.split(',') : [userID_Path];\n\tconst ips = await requestCFIps(options.url, options);\n\tconst allProxyIPs = proxyIPs.concat(ips);\n\t// console.log(ips);\n\t// Prepare output array\n\tlet output = [];\n\n\t// Generate output string for each userID\n\tuserIDArray.forEach((userID) => {\n\t\t// Check if the hostName is a Cloudflare Pages domain, if not, generate HTTP configurations\n\t\t// reasons: pages.dev not support http only https\n\t\tif (!hostName.includes('pages.dev')) {\n\t\t\t// Iterate over all ports for http\n\t\t\tportArray_http.forEach((port) => {\n\t\t\t\tconst commonUrlPart_http = `:${port}?encryption=none&security=none&fp=random&type=ws&host=${hostName}&path=%2F%3Fed%3D2048#${hostName}-HTTP`;\n\t\t\t\tconst vlessMainHttp = `vless://${userID}@${hostName}${commonUrlPart_http}`;\n\n\t\t\t\t// For each proxy IP, generate a VLESS configuration and add to output\n\t\t\t\tallProxyIPs.forEach((proxyIP) => {\n\t\t\t\t\tconst vlessSecHttp = `vless://${userID}@${proxyIP}${commonUrlPart_http}-${proxyIP}-EDtunnel`;\n\t\t\t\t\toutput.push(`${vlessMainHttp}`);\n\t\t\t\t\toutput.push(`${vlessSecHttp}`);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// Iterate over all ports for https\n\t\tportArray_https.forEach((port) => {\n\t\t\tconst commonUrlPart_https = `:${port}?encryption=none&security=tls&sni=${hostName}&fp=random&type=ws&host=${hostName}&path=%2F%3Fed%3D2048#${hostName}-HTTPS`;\n\t\t\tconst vlessMainHttps = `vless://${userID}@${hostName}${commonUrlPart_https}`;\n\n\t\t\t// For each proxy IP, generate a VLESS configuration and add to output\n\t\t\tallProxyIPs.forEach((proxyIP) => {\n\t\t\t\tconst vlessSecHttps = `vless://${userID}@${proxyIP}${commonUrlPart_https}-${proxyIP}-EDtunnel`;\n\t\t\t\toutput.push(`${vlessMainHttps}`);\n\t\t\t\toutput.push(`${vlessSecHttps}`);\n\t\t\t});\n\t\t});\n\t});\n\tconst setResponse = new Set(output);\n\tconst newResponse = [...setResponse]; \n\t// Join output with newlines\n\treturn newResponse.join('\\n');\n}\n\nconst options = {\n  url: 'https://api.hostmonit.com/get_optimization_ip',\n  method: 'POST',\n  headers: {\n    'authority': 'api.hostmonit.com',\n    'accept': 'application/json, text/plain, */*',\n    'accept-language': 'zh-CN,zh;q=0.7',\n    'content-type': 'application/json',\n    'origin': 'https://stock.hostmonit.com',\n    'referer': 'https://stock.hostmonit.com/',\n    'sec-ch-ua': '\"Not/A)Brand\";v=\"99\", \"Brave\";v=\"115\", \"Chromium\";v=\"115\"',\n    'sec-ch-ua-mobile': '?0',\n    'sec-ch-ua-platform': '\"macOS\"',\n    'sec-fetch-dest': 'empty',\n    'sec-fetch-mode': 'cors',\n    'sec-fetch-site': 'same-site',\n    'sec-gpc': '1',\n    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36'\n  },\n  data: {key: 'iDetkOys'}\n};\n\nasync function requestCFIps(url, options) {\n\tconst response = await fetch(url, {\n\t  method: options.method,\n\t  headers: options.headers,\n\t  body: JSON.stringify(options.data) \n\t});\n  \n\tconst data = await response.json();\n\tconst ips = [];\n\tfor (let item of data.info) {\n\t\tips.push(item.ip);\n\t}\n\treturn ips;\n}\n"],
  "mappings": "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",
  "names": ["connect", "userID", "proxyIPs", "proxyIP", "dohURL", "nodeId", "apiToken", "apiHost", "isValidUUID", "worker_default", "request", "env", "ctx", "userID_Path", "upgradeHeader", "url", "hostname", "port", "socket", "writer", "writeError", "reader", "value", "readError", "connectError", "vlessConfig", "getVLESSConfig", "searchParams", "createVLESSSub", "createVLESSSubByOptimizationIp", "hostnames", "newHeaders", "cache", "response", "cloneResponse", "vlessOverWSHandler", "err", "e", "vlessOverWSHandler", "request", "webSocketPair", "client", "webSocket", "address", "portWithRandomLog", "log", "info", "event", "earlyDataHeader", "readableWebSocketStream", "makeReadableWebSocketStream", "remoteSocketWapper", "udpStreamWrite", "isDns", "chunk", "controller", "writer", "hasError", "message", "portRemote", "addressRemote", "rawDataIndex", "vlessVersion", "isUDP", "processVlessHeader", "userID", "vlessResponseHeader", "rawClientData", "write", "handleUDPOutBound", "handleTCPOutBound", "reason", "err", "handleTCPOutBound", "remoteSocket", "addressRemote", "portRemote", "rawClientData", "webSocket", "vlessResponseHeader", "log", "connectAndWrite", "address", "port", "tcpSocket", "connect", "writer", "retry", "proxyIP", "error", "safeCloseWebSocket", "remoteSocketToWS", "makeReadableWebSocketStream", "webSocketServer", "earlyDataHeader", "readableStreamCancel", "controller", "event", "message", "err", "earlyData", "base64ToArrayBuffer", "reason", "processVlessHeader", "vlessBuffer", "userID", "version", "isValidUser", "isUDP", "slicedBuffer", "slicedBufferString", "stringify", "uuids", "userUuid", "optLength", "command", "portIndex", "portBuffer", "addressIndex", "addressType", "addressLength", "addressValueIndex", "addressValue", "dataView", "ipv6", "i", "remoteChunkCount", "chunks", "vlessHeader", "hasIncomingData", "chunk", "WS_READY_STATE_OPEN", "base64Str", "decode", "c", "isValidUUID", "uuid", "WS_READY_STATE_CLOSING", "socket", "byteToHex", "unsafeStringify", "arr", "offset", "handleUDPOutBound", "isVlessHeaderSent", "transformStream", "index", "lengthBuffer", "udpPakcetLength", "udpData", "dnsQueryResult", "dohURL", "udpSize", "udpSizeBuffer", "getVLESSConfig", "userIDs", "hostName", "commonUrlPart", "separator", "hashSeparator", "userIDArray", "output", "header", "clash_link", "vlessMain", "vlessSec", "createVLESSSub", "userID_Path", "portArray_http", "portArray_https", "commonUrlPart_http", "vlessMainHttp", "proxyIPs", "vlessSecHttp", "commonUrlPart_https", "vlessMainHttps", "vlessSecHttps", "createVLESSSubByOptimizationIp", "ips", "requestCFIps", "options", "allProxyIPs", "url", "data", "item"]
}
